
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/codeharik/GoMQ/api/v1/log.pb.go (0.0%)</option>
				
				<option value="file1">github.com/codeharik/GoMQ/cmd/server/handlers.go (0.0%)</option>
				
				<option value="file2">github.com/codeharik/GoMQ/cmd/server/init.go (0.0%)</option>
				
				<option value="file3">github.com/codeharik/GoMQ/cmd/server/main.go (0.0%)</option>
				
				<option value="file4">github.com/codeharik/GoMQ/pkg/barrel/barrel.go (70.8%)</option>
				
				<option value="file5">github.com/codeharik/GoMQ/pkg/barrel/compact.go (7.8%)</option>
				
				<option value="file6">github.com/codeharik/GoMQ/pkg/barrel/config.go (51.6%)</option>
				
				<option value="file7">github.com/codeharik/GoMQ/pkg/barrel/flock.go (61.5%)</option>
				
				<option value="file8">github.com/codeharik/GoMQ/pkg/barrel/header.go (100.0%)</option>
				
				<option value="file9">github.com/codeharik/GoMQ/pkg/barrel/keydir.go (38.9%)</option>
				
				<option value="file10">github.com/codeharik/GoMQ/pkg/barrel/ops.go (77.5%)</option>
				
				<option value="file11">github.com/codeharik/GoMQ/pkg/barrel/utils.go (40.9%)</option>
				
				<option value="file12">github.com/codeharik/GoMQ/pkg/datafile/datafile.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        (unknown)
// source: v1/log.proto

package log_v1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Record struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Value  []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
        Offset uint64 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *Record) Reset() <span class="cov0" title="0">{
        *x = Record{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_v1_log_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Record) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Record) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Record) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_v1_log_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Record.ProtoReflect.Descriptor instead.
func (*Record) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_v1_log_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Record) GetValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Record) GetOffset() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_v1_log_proto protoreflect.FileDescriptor

var file_v1_log_proto_rawDesc = []byte{
        0x0a, 0x0c, 0x76, 0x31, 0x2f, 0x6c, 0x6f, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06,
        0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x22, 0x36, 0x0a, 0x06, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64,
        0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x42, 0x70,
        0x0a, 0x0a, 0x63, 0x6f, 0x6d, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x42, 0x08, 0x4c, 0x6f,
        0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x1f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
        0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x64, 0x65, 0x68, 0x61, 0x72, 0x69, 0x6b, 0x2f, 0x61,
        0x70, 0x69, 0x2f, 0x6c, 0x6f, 0x67, 0x5f, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x4c, 0x58, 0x58, 0xaa,
        0x02, 0x06, 0x4c, 0x6f, 0x67, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x06, 0x4c, 0x6f, 0x67, 0x5c, 0x56,
        0x31, 0xe2, 0x02, 0x12, 0x4c, 0x6f, 0x67, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65,
        0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x07, 0x4c, 0x6f, 0x67, 0x3a, 0x3a, 0x56, 0x31,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_v1_log_proto_rawDescOnce sync.Once
        file_v1_log_proto_rawDescData = file_v1_log_proto_rawDesc
)

func file_v1_log_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_v1_log_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_v1_log_proto_rawDescData = protoimpl.X.CompressGZIP(file_v1_log_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_v1_log_proto_rawDescData</span>
}

var file_v1_log_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_v1_log_proto_goTypes = []any{
        (*Record)(nil), // 0: log.v1.Record
}
var file_v1_log_proto_depIdxs = []int32{
        0, // [0:0] is the sub-list for method output_type
        0, // [0:0] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_v1_log_proto_init() }</span>
func file_v1_log_proto_init() <span class="cov0" title="0">{
        if File_v1_log_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_v1_log_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*Record); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_v1_log_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_v1_log_proto_goTypes,
                DependencyIndexes: file_v1_log_proto_depIdxs,
                MessageInfos:      file_v1_log_proto_msgTypes,
        }.Build()
        File_v1_log_proto = out.File
        file_v1_log_proto_rawDesc = nil
        file_v1_log_proto_goTypes = nil
        file_v1_log_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "time"

        "github.com/tidwall/redcon"
)

func (app *App) ping(conn redcon.Conn, cmd redcon.Command) <span class="cov0" title="0">{
        conn.WriteString("PONG")
}</span>

func (app *App) quit(conn redcon.Conn, cmd redcon.Command) <span class="cov0" title="0">{
        conn.WriteString("OK")
        conn.Close()
}</span>

func (app *App) set(conn redcon.Conn, cmd redcon.Command) <span class="cov0" title="0">{
        var withExpiry bool
        switch len(cmd.Args) </span>{
        case 4:<span class="cov0" title="0">
                withExpiry = true</span>
        case 3:<span class="cov0" title="0">
                withExpiry = false</span>
        default:<span class="cov0" title="0">
                conn.WriteError("ERR wrong number of arguments for '" + string(cmd.Args[0]) + "' command")
                return</span>
        }

        <span class="cov0" title="0">var (
                key = string(cmd.Args[1])
                val = cmd.Args[2]
        )
        if withExpiry </span><span class="cov0" title="0">{
                expiry, err := time.ParseDuration(string(cmd.Args[3]))
                if err != nil </span><span class="cov0" title="0">{
                        conn.WriteError("ERR invalid duration" + string(cmd.Args[3]))
                        return
                }</span>
                <span class="cov0" title="0">if err := app.barrel.PutEx(key, val, expiry); err != nil </span><span class="cov0" title="0">{
                        conn.WriteString(fmt.Sprintf("ERR: %s", err))
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if err := app.barrel.Put(key, val); err != nil </span><span class="cov0" title="0">{
                        conn.WriteString(fmt.Sprintf("ERR: %s", err))
                        return
                }</span>
        }

        <span class="cov0" title="0">conn.WriteString("OK")</span>
}

func (app *App) get(conn redcon.Conn, cmd redcon.Command) <span class="cov0" title="0">{
        if len(cmd.Args) != 2 </span><span class="cov0" title="0">{
                conn.WriteError("ERR wrong number of arguments for '" + string(cmd.Args[0]) + "' command")
                return
        }</span>
        <span class="cov0" title="0">key := string(cmd.Args[1])
        val, err := app.barrel.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                conn.WriteString(fmt.Sprintf("ERR: %s", err))
                return
        }</span>

        <span class="cov0" title="0">conn.WriteBulk(val)</span>
}

func (app *App) delete(conn redcon.Conn, cmd redcon.Command) <span class="cov0" title="0">{
        if len(cmd.Args) != 2 </span><span class="cov0" title="0">{
                conn.WriteError("ERR wrong number of arguments for '" + string(cmd.Args[0]) + "' command")
                return
        }</span>
        <span class="cov0" title="0">key := string(cmd.Args[1])
        err := app.barrel.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                conn.WriteString(fmt.Sprintf("ERR: %s", err))
                return
        }</span>

        <span class="cov0" title="0">conn.WriteNull()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "os"
        "strings"

        flag "github.com/spf13/pflag"

        "github.com/knadh/koanf"
        "github.com/knadh/koanf/parsers/toml"
        "github.com/knadh/koanf/providers/env"
        "github.com/knadh/koanf/providers/file"
        "github.com/zerodha/logf"
)

// initLogger initializes logger instance.
func initLogger(ko *koanf.Koanf) logf.Logger <span class="cov0" title="0">{
        opts := logf.Opts{EnableCaller: true}
        if ko.String("app.log") == "debug" </span><span class="cov0" title="0">{
                opts.Level = logf.DebugLevel
                opts.EnableColor = true
        }</span>
        <span class="cov0" title="0">return logf.New(opts)</span>
}

// initConfig loads config to `ko` object.
func initConfig() (*koanf.Koanf, error) <span class="cov0" title="0">{
        var (
                ko = koanf.New(".")
                f  = flag.NewFlagSet("front", flag.ContinueOnError)
        )

        // Configure Flags.
        f.Usage = func() </span><span class="cov0" title="0">{
                fmt.Println(f.FlagUsages())
                os.Exit(0)
        }</span>

        // Register `--config` flag.
        <span class="cov0" title="0">cfgPath := f.String("config", "config.sample.toml", "Path to a config file to load.")

        // Parse and Load Flags.
        err := f.Parse(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = ko.Load(file.Provider(*cfgPath), toml.Parser())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = ko.Load(env.Provider("BARRELDB_", ".", func(s string) string </span><span class="cov0" title="0">{
                return strings.Replace(strings.ToLower(
                        strings.TrimPrefix(s, "BARRELDB_")), "__", ".", -1)
        }</span>), nil)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ko, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "github.com/codeharik/GoMQ/pkg/barrel"
        "github.com/tidwall/redcon"
        "github.com/zerodha/logf"
)

// Version of the build. This is injected at build-time.
var buildString = "unknown"

type App struct {
        lo     logf.Logger
        barrel *barrel.Barrel
}

func main() <span class="cov0" title="0">{
        // Initialise and load the config.
        ko, err := initConfig()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("error loading config: %v", err)
                os.Exit(-1)
        }</span>

        <span class="cov0" title="0">app := &amp;App{
                lo: initLogger(ko),
        }
        app.lo.Info("booting barreldb server", "version", buildString)

        // Set config options for barrel.
        cfg := []barrel.Config{barrel.WithDir(ko.MustString("app.dir")), barrel.WithAutoSync()}
        if ko.Bool("app.read_only") </span><span class="cov0" title="0">{
                cfg = append(cfg, barrel.WithReadOnly())
        }</span>
        <span class="cov0" title="0">if ko.Bool("app.debug") </span><span class="cov0" title="0">{
                cfg = append(cfg, barrel.WithDebug())
        }</span>

        // Initialise barrel.
        <span class="cov0" title="0">barrel, err := barrel.Init(cfg...)
        if err != nil </span><span class="cov0" title="0">{
                app.lo.Fatal("error opening barrel db", "error", err)
        }</span>
        <span class="cov0" title="0">app.barrel = barrel

        // Initialise server.
        mux := redcon.NewServeMux()
        mux.HandleFunc("ping", app.ping)
        mux.HandleFunc("quit", app.quit)
        mux.HandleFunc("set", app.set)
        mux.HandleFunc("get", app.get)
        mux.HandleFunc("del", app.delete)

        // Create a channel to listen for cancellation signals.
        // Create a new context which is cancelled when `SIGINT`/`SIGTERM` is received.
        ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)

        srvr := redcon.NewServer(ko.MustString("server.address"),
                mux.ServeRESP,
                func(conn redcon.Conn) bool </span><span class="cov0" title="0">{
                        // use this function to accept or deny the connection.
                        return true
                }</span>,
                func(conn redcon.Conn, err error) {<span class="cov0" title="0">
                        // this is called when the connection has been closed
                }</span>,
        )

        // Sart the server in a goroutine.
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := srvr.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        app.lo.Fatal("failed to listen and serve", "error", err)
                }</span>
        }()

        // Listen on the close channel indefinitely until a
        // `SIGINT` or `SIGTERM` is received.
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Cancel the context to gracefully shutdown and perform
        // any cleanup tasks.
        cancel()
        app.barrel.Shutdown()
        srvr.Close()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package barrel

import (
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/codeharik/GoMQ/pkg/datafile"
        "github.com/zerodha/logf"
)

const (
        LOCKFILE   = "barrel.lock"
        HINTS_FILE = "barrel.hints"
)

type Barrel struct {
        sync.Mutex

        lo      logf.Logger
        bufPool sync.Pool // Pool of byte buffers used for writing.
        opts    *Options

        keydir KeyDir                     // In-memory hashmap of all active keys.
        df     *datafile.DataFile         // Active datafile.
        stale  map[int]*datafile.DataFile // Map of older datafiles with their IDs.
        flockF *os.File                   // Lockfile to prevent multiple write access to same datafile.
}

// initLogger initializes logger instance.
func initLogger(debug bool) logf.Logger <span class="cov6" title="3">{
        opts := logf.Opts{EnableCaller: true}
        if debug </span><span class="cov1" title="1">{
                opts.Level = logf.DebugLevel
        }</span>
        <span class="cov6" title="3">return logf.New(opts)</span>
}

// Init initialises a datastore for storing data.
func Init(cfg ...Config) (*Barrel, error) <span class="cov6" title="3">{
        // Set options.
        opts := DefaultOptions()
        for _, opt := range cfg </span><span class="cov10" title="7">{
                if err := opt(opts); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov6" title="3">var (
                lo     = initLogger(opts.debug)
                index  = 0
                flockF *os.File
                stale  = map[int]*datafile.DataFile{}
        )

        // Load existing datafiles
        files, err := getDataFiles(opts.dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error loading data files: %w", err)
        }</span>

        <span class="cov6" title="3">if len(files) &gt; 0 </span><span class="cov0" title="0">{
                // Get the existing ids.
                ids, err := getIDs(files)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing ids for existing files: %w", err)
                }</span>

                // Increment the index to write to a new datafile.
                <span class="cov0" title="0">index = ids[len(ids)-1] + 1

                // Add all older datafiles to the list of stale files.
                for _, idx := range ids </span><span class="cov0" title="0">{
                        df, err := datafile.New(opts.dir, idx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">stale[idx] = df</span>
                }
        }

        // If not running in a read only mode then create a lockfile to ensure only one process writes to the db directory.
        <span class="cov6" title="3">if !opts.readOnly </span><span class="cov6" title="3">{
                // Check if a lockfile already exists.
                lockPath := filepath.Join(opts.dir, LOCKFILE)
                if exists(lockPath) </span><span class="cov0" title="0">{
                        return nil, ErrLocked
                }</span> else<span class="cov6" title="3"> {
                        flockF, err = createFlockFile(lockPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error creating lockfile: %w", err)
                        }</span>
                }
        }

        // Initialise a db store.
        <span class="cov6" title="3">df, err := datafile.New(opts.dir, index)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialise an empty keydir.
        <span class="cov6" title="3">keydir := make(KeyDir, 0)

        // Check if a hints file already exists and then use that to populate the hashtable.
        hintsPath := filepath.Join(opts.dir, HINTS_FILE)
        if exists(hintsPath) </span><span class="cov0" title="0">{
                if err := keydir.Decode(hintsPath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error populating hashtable from hints file: %w", err)
                }</span>
        }

        // Initialise barrel.
        <span class="cov6" title="3">barrel := &amp;Barrel{
                opts:   opts,
                lo:     lo,
                df:     df,
                stale:  stale,
                flockF: flockF,
                keydir: keydir,
                bufPool: sync.Pool{New: func() any </span><span class="cov1" title="1">{
                        return bytes.NewBuffer([]byte{})
                }</span>},
        }

        // Spawn a goroutine which runs in background and compacts all datafiles in a new single datafile.
        <span class="cov6" title="3">go barrel.RunCompaction(opts.compactInterval)

        // Spawn a goroutine which checks for the file size of the active file at periodic interval.
        go barrel.ExamineFileSize(barrel.opts.checkFileSizeInterval)

        // Spawn a goroutine which flushes the file to disk periodically.
        if barrel.opts.syncInterval != nil </span><span class="cov0" title="0">{
                go barrel.SyncFile(*opts.syncInterval)
        }</span>

        <span class="cov6" title="3">return barrel, nil</span>
}

// Shutdown closes all the open file descriptors and removes any file locks.
// If non running in a read-only mode, it's essential to call close so that it
// removes any file locks on the database directory. Not calling close will prevent
// future startups until it's removed manually.
func (b *Barrel) Shutdown() error <span class="cov6" title="3">{
        b.Lock()
        defer b.Unlock()

        // Generate a hints file.
        if err := b.generateHints(); err != nil </span><span class="cov0" title="0">{
                b.lo.Error("error generating hints file", "error", err)
                return err
        }</span>

        // Close all active file handlers.
        <span class="cov6" title="3">if err := b.df.Close(); err != nil </span><span class="cov0" title="0">{
                b.lo.Error("error closing active db file", "error", err, "id", b.df.ID())
                return err
        }</span>

        // Close all stale datafiles as well.
        <span class="cov6" title="3">for _, df := range b.stale </span><span class="cov0" title="0">{
                if err := df.Close(); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error closing active db file", "error", err, "id", df.ID())
                        return err
                }</span>
        }

        // Cleanup the lock file.
        <span class="cov6" title="3">if !b.opts.readOnly </span><span class="cov6" title="3">{
                if err := destroyFlockFile(b.flockF); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error destroying lock file", "error", err)
                        return err
                }</span>
        }

        <span class="cov6" title="3">return nil</span>
}

// Put takes a key and value and encodes the data in bytes and writes to the db file.
// It also stores the key with some metadata in memory.
// This metadata helps for faster reads as the last position of the file is recorded so only
// a single disk seek is required to read value.
func (b *Barrel) Put(k string, val []byte) error <span class="cov1" title="1">{
        b.Lock()
        defer b.Unlock()

        if b.opts.readOnly </span><span class="cov0" title="0">{
                return ErrReadOnly
        }</span>

        // Validate key and value.
        <span class="cov1" title="1">if err := validateKV(k, val); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">b.lo.Debug("storing data", "key", k, "val", val)
        return b.put(b.df, k, val, nil)</span>
}

// PutEx is same as Put but also takes an additional expiry time.
func (b *Barrel) PutEx(k string, val []byte, ex time.Duration) error <span class="cov1" title="1">{
        b.Lock()
        defer b.Unlock()

        if b.opts.readOnly </span><span class="cov0" title="0">{
                return ErrReadOnly
        }</span>

        // Validate key and value.
        <span class="cov1" title="1">if err := validateKV(k, val); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add the expiry to the current time.
        <span class="cov1" title="1">expiry := time.Now().Add(ex)

        b.lo.Debug("storing data with expiry", "key", k, "val", val, "expiry", ex.String())
        return b.put(b.df, k, val, &amp;expiry)</span>
}

// Get takes a key and finds the metadata in the in-memory hashtable (Keydir).
// Using the offset present in metadata it finds the record in the datafile with a single disk seek.
// It further decodes the record and returns the value as a byte array for the given key.
func (b *Barrel) Get(k string) ([]byte, error) <span class="cov6" title="3">{
        b.Lock()
        defer b.Unlock()

        b.lo.Debug("fetching data", "key", k)
        record, err := b.get(k)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // If expired, then don't return any result.
        <span class="cov4" title="2">if record.isExpired() </span><span class="cov1" title="1">{
                return nil, ErrExpiredKey
        }</span>

        // If invalid checksum, return error.
        <span class="cov1" title="1">if !record.isValidChecksum() </span><span class="cov0" title="0">{
                return nil, ErrChecksumMismatch
        }</span>

        <span class="cov1" title="1">return record.Value, nil</span>
}

// Delete creates a tombstone record for the given key. The tombstone value is simply an empty byte array.
// Actual deletes happen in background when merge is called.
// Since the file is opened in append-only mode, the new value of the key
// is overwritten both on disk and in memory as a tombstone record.
func (b *Barrel) Delete(k string) error <span class="cov1" title="1">{
        b.Lock()
        defer b.Unlock()

        if b.opts.readOnly </span><span class="cov0" title="0">{
                return ErrReadOnly
        }</span>

        <span class="cov1" title="1">b.lo.Debug("deleting key", "key", k)
        return b.delete(k)</span>
}

// List iterates over all keys and returns the list of keys.
func (b *Barrel) List() []string <span class="cov1" title="1">{
        b.Lock()
        defer b.Unlock()

        keys := make([]string, 0, len(b.keydir))

        for k := range b.keydir </span><span class="cov1" title="1">{
                keys = append(keys, k)
        }</span>

        <span class="cov1" title="1">return keys</span>
}

// Len iterates over all keys and returns the total number of keys.
func (b *Barrel) Len() int <span class="cov1" title="1">{
        b.Lock()
        defer b.Unlock()

        return len(b.keydir)
}</span>

// Fold iterates over all keys and calls the given function for each key.
func (b *Barrel) Fold(fn func(k string) error) error <span class="cov1" title="1">{
        b.Lock()
        defer b.Unlock()

        // Call fn for each key.
        for k := range b.keydir </span><span class="cov1" title="1">{
                if err := fn(k); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Sync calls fsync(2) on the active data file.
func (b *Barrel) Sync() error <span class="cov1" title="1">{
        b.Lock()
        defer b.Unlock()

        return b.df.Sync()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package barrel

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/codeharik/GoMQ/pkg/datafile"
)

// ExamineFileSize checks for file size at a periodic interval.
// It examines the file size of the active db file and marks it as stale
// if the file size exceeds the configured size.
func (b *Barrel) ExamineFileSize(evalInterval time.Duration) <span class="cov10" title="3">{
        evalTicker := time.NewTicker(evalInterval).C
        for range evalTicker </span><span class="cov0" title="0">{
                if err := b.rotateDF(); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error rotating db file", "error", err)
                }</span>
        }
}

// RunCompaction runs cleanup process to compact the keys and cleanup
// dead/expired keys at a periodic interval. This helps to save disk space
// and merge old inactive db files in a single file. It also generates a hints file
// which helps in caching all the keys during a cold start.
func (b *Barrel) RunCompaction(evalInterval time.Duration) <span class="cov10" title="3">{
        evalTicker := time.NewTicker(evalInterval).C
        for range evalTicker </span><span class="cov0" title="0">{
                b.Lock()

                if err := b.cleanupExpired(); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error removing expired keys", "error", err)
                }</span>
                <span class="cov0" title="0">if err := b.merge(); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error merging old files", "error", err)
                }</span>
                <span class="cov0" title="0">if err := b.generateHints(); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error generating hints file", "error", err)
                }</span>

                <span class="cov0" title="0">b.Unlock()</span>
        }
}

// SyncFile checks for file size at a periodic interval.
// It examines the file size of the active db file and marks it as stale
// if the file size exceeds the configured size.
func (b *Barrel) SyncFile(evalInterval time.Duration) <span class="cov0" title="0">{
        evalTicker := time.NewTicker(evalInterval).C
        for range evalTicker </span><span class="cov0" title="0">{
                if err := b.Sync(); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error syncing db file to disk", "error", err)
                }</span>
        }
}

// rotateDF checks if the active file size has crossed the threshold
// of max allowed file size. If it has, it replaces the open file descriptors
// pointing to that file with a new file and adds the current file to list of
// stale files.
func (b *Barrel) rotateDF() error <span class="cov0" title="0">{
        b.Lock()
        defer b.Unlock()

        size, err := b.df.Size()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the file is below the threshold of max size, do no action.
        <span class="cov0" title="0">b.lo.Debug("checking if db file has exceeded max_size", "current_size", size, "max_size", b.opts.maxActiveFileSize)
        if size &lt; b.opts.maxActiveFileSize </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">oldID := b.df.ID()

        // Add this datafile to list of stale files.
        b.stale[oldID] = b.df

        // Create a new datafile.
        df, err := datafile.New(b.opts.dir, oldID+1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Replace with a new instance of datafile.
        <span class="cov0" title="0">b.df = df

        return nil</span>
}

// generateHints encodes the contents of the in-memory hashtable
// as `gob` and writes the data to a hints file.
func (b *Barrel) generateHints() error <span class="cov10" title="3">{
        path := filepath.Join(b.opts.dir, HINTS_FILE)
        if err := b.keydir.Encode(path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="3">return nil</span>
}

// cleanupExpired removes the expired keys.
func (b *Barrel) cleanupExpired() error <span class="cov0" title="0">{
        // Iterate over all keys and delete all keys which are expired.
        for k := range b.keydir </span><span class="cov0" title="0">{
                record, err := b.get(k)
                if err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error fetching key", "key", k, "error", err)
                        continue</span>
                }
                <span class="cov0" title="0">if record.isExpired() </span><span class="cov0" title="0">{
                        b.lo.Debug("deleting key since it's expired", "key", k)
                        // Delete the key.
                        if err := b.delete(k); err != nil </span><span class="cov0" title="0">{
                                b.lo.Error("error deleting key", "key", k, "error", err)
                                continue</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Merge is the process of merging all datafiles in a single file.
// In this process, all the expired/deleted keys are cleaned up and old files
// are removed from the disk.
func (b *Barrel) merge() error <span class="cov0" title="0">{
        var mergefsync bool

        // There should be atleast 2 old files to merge.
        if len(b.stale) &lt; 2 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a new datafile for storing the output of merged files.
        // Use a temp directory to store the file and move to main directory after merge is over.
        <span class="cov0" title="0">tmpMergeDir, err := os.MkdirTemp("", "merged")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tmpMergeDir)

        mergeDF, err := datafile.New(tmpMergeDir, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Disable fsync for merge process and manually fsync at the end of merge.
        <span class="cov0" title="0">if b.opts.alwaysFSync </span><span class="cov0" title="0">{
                mergefsync = true
                b.opts.alwaysFSync = false
        }</span>

        // Loop over all active keys in the hashmap and write the updated values to merged database.
        // Since the keydir has updated values of all keys, all the old keys which are expired/deleted/overwritten
        // will be cleaned up in the merged database.

        <span class="cov0" title="0">for k := range b.keydir </span><span class="cov0" title="0">{
                record, err := b.get(k)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := b.put(mergeDF, k, record.Value, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Now close all the existing datafile handlers.
        <span class="cov0" title="0">for _, df := range b.stale </span><span class="cov0" title="0">{
                if err := df.Close(); err != nil </span><span class="cov0" title="0">{
                        b.lo.Error("error closing df", "id", df.ID(), "error", err)
                        continue</span>
                }
        }

        // Reset the old map.
        <span class="cov0" title="0">b.stale = make(map[int]*datafile.DataFile, 0)

        // Delete the existing .db files
        err = filepath.Walk(b.opts.dir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if filepath.Ext(path) == ".db" </span><span class="cov0" title="0">{
                        err := os.Remove(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Move the merged file to the main directory.
        <span class="cov0" title="0">os.Rename(filepath.Join(tmpMergeDir, fmt.Sprintf(datafile.ACTIVE_DATAFILE, 0)),
                filepath.Join(b.opts.dir, fmt.Sprintf(datafile.ACTIVE_DATAFILE, 0)))

        // Set the merged DF as the active DF.
        b.df = mergeDF

        if mergefsync </span><span class="cov0" title="0">{
                b.opts.alwaysFSync = true
                b.df.Sync()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package barrel

import (
        "time"
)

const (
        defaultSyncInterval      = time.Minute * 1
        defaultCompactInterval   = time.Hour * 6
        defaultFileSizeInterval  = time.Minute * 1
        defaultMaxActiveFileSize = int64(1 &lt;&lt; 32) // 4GB.
)

// Options represents configuration options for managing a datastore.
type Options struct {
        debug                 bool           // Enable debug logging.
        dir                   string         // Path for storing data files.
        readOnly              bool           // Whether this datastore should be opened in a read-only mode. Only one process at a time can open it in R-W mode.
        alwaysFSync           bool           // Should flush filesystem buffer after every right.
        syncInterval          *time.Duration // Interval to sync the active file on disk.
        compactInterval       time.Duration  // Interval to compact old files.
        checkFileSizeInterval time.Duration  // Interval to check the file size of the active DB.
        maxActiveFileSize     int64          // Max size of active file in bytes. On exceeding this size it's rotated.
}

// Config is a function on the Options for barreldb.
// These are used to configure particular options.
type Config func(*Options) error

func DefaultOptions() *Options <span class="cov10" title="3">{
        return &amp;Options{
                debug:                 false,
                dir:                   ".",
                readOnly:              false,
                alwaysFSync:           false,
                maxActiveFileSize:     defaultMaxActiveFileSize,
                compactInterval:       defaultCompactInterval,
                checkFileSizeInterval: defaultFileSizeInterval,
        }
}</span>

func WithDebug() Config <span class="cov1" title="1">{
        return func(o *Options) error </span><span class="cov1" title="1">{
                o.debug = true
                return nil
        }</span>
}

func WithDir(dir string) Config <span class="cov10" title="3">{
        return func(o *Options) error </span><span class="cov10" title="3">{
                o.dir = dir
                return nil
        }</span>
}

func WithReadOnly() Config <span class="cov0" title="0">{
        return func(o *Options) error </span><span class="cov0" title="0">{
                o.readOnly = true
                return nil
        }</span>
}

func WithAlwaysSync() Config <span class="cov1" title="1">{
        return func(o *Options) error </span><span class="cov1" title="1">{
                o.alwaysFSync = true
                return nil
        }</span>
}

func WithAutoSync() Config <span class="cov0" title="0">{
        return func(o *Options) error </span><span class="cov0" title="0">{
                o.alwaysFSync = false
                d := defaultSyncInterval
                o.syncInterval = &amp;d
                return nil
        }</span>
}

func WithBackgrondSync(interval time.Duration) Config <span class="cov0" title="0">{
        return func(o *Options) error </span><span class="cov0" title="0">{
                o.alwaysFSync = false
                o.syncInterval = &amp;interval
                return nil
        }</span>
}

func WithCompactInterval(interval time.Duration) Config <span class="cov0" title="0">{
        return func(o *Options) error </span><span class="cov0" title="0">{
                o.compactInterval = interval
                return nil
        }</span>
}

func WithCheckFileSizeInterval(interval time.Duration) Config <span class="cov1" title="1">{
        return func(o *Options) error </span><span class="cov1" title="1">{
                o.checkFileSizeInterval = interval
                return nil
        }</span>
}

func WithMaxActiveFileSize(size int64) Config <span class="cov1" title="1">{
        return func(o *Options) error </span><span class="cov1" title="1">{
                o.maxActiveFileSize = size
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// package barrel

// import (
//         "fmt"
//         "os"

//         "github.com/gofrs/flock"
// )

// // Exists returns true if the given path exists on the filesystem.
// func Exists(path string) bool {
//         if _, err := os.Stat(path); err != nil {
//                 return false
//         }
//         return true
// }

// // CreateFlockFile creates a file lock for the database directory.
// func CreateFlockFile(flockFile string) *flock.Flock {
//         fileLock := flock.New(flockFile)
//         locked, err := fileLock.TryLock()
//         if err != nil {
//                 fmt.Printf("Failed to acquire lock")
//         } else if locked {
//                 fmt.Printf("Lock acquired")
//         }
//         return fileLock
// }

// // DestroyFlockFile removes a file lock for the database directory.
// func DestroyFlockFile(flockF *flock.Flock) error {
//         // Close any open fd.
//         if err := flockF.Close(); err != nil {
//                 return fmt.Errorf("cannot close fd on file %q: %w", flockF.Path(), err)
//         }
//         // Remove the lock file from the filesystem.
//         if err := os.Remove(flockF.Path()); err != nil {
//                 return fmt.Errorf("cannot remove file %q: %w", flockF.Path(), err)
//         }
//         return nil
// }

package barrel

import (
        "fmt"
        "os"

        "golang.org/x/sys/unix"
)

// createFlockFile creates a file lock for the database directory.
func createFlockFile(flockFile string) (*os.File, error) <span class="cov10" title="3">{
        flockF, err := os.Create(flockFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create lock file %q: %w", flockFile, err)
        }</span>
        <span class="cov10" title="3">if err := unix.Flock(int(flockF.Fd()), unix.LOCK_EX|unix.LOCK_NB); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot acquire lock on file %q: %w", flockFile, err)
        }</span>
        <span class="cov10" title="3">return flockF, nil</span>
}

// destroyFlockFile removes a file lock for the database directory.
func destroyFlockFile(flockF *os.File) error <span class="cov10" title="3">{
        // Unlock the file.
        if err := unix.Flock(int(flockF.Fd()), unix.LOCK_UN); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot unlock lock on file %q: %w", flockF.Name(), err)
        }</span>
        // Close any open fd.
        <span class="cov10" title="3">if err := flockF.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot close fd on file %q: %w", flockF.Name(), err)
        }</span>
        // Remove the lock file from the filesystem.
        <span class="cov10" title="3">if err := os.Remove(flockF.Name()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot remove file %q: %w", flockF.Name(), err)
        }</span>
        <span class="cov10" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package barrel

import (
        "bytes"
        "encoding/binary"
        "hash/crc32"
        "time"
)

const (
        MaxKeySize   = 1&lt;&lt;32 - 1
        MaxValueSize = 1&lt;&lt;32 - 1
)

/*
Record is a binary representation of how each record is persisted in the disk.
Header represents how the record is stored and some metadata with it.
For storing CRC checksum hash, timestamp and expiry of record, each field uses 4 bytes. (uint32 == 32 bits).
The next field stores the max size of the key which is also represented with uint32. So the max size of the key
can not be more than 2^32-1 which is ~ 4.3GB.
The next field stores the max size of the value which is also represented with unint32. Max size of value can not be more
than 2^32-1 which is ~ 4.3GB.

Each entry cannot exceed more than ~8.6GB as a theoretical limit.
In a practical sense, this is also constrained by the memory of the underlying VM
where this program would run.

Representation of the record stored on disk.
------------------------------------------------------------------------------
| crc(4) | time(4) | expiry (4) | key_size(4) | val_size(4) | key | val      |
------------------------------------------------------------------------------
*/
type Record struct {
        Header Header
        Key    string
        Value  []byte
}

// Header represents the fixed width fields present at the start of every record.
type Header struct {
        Checksum  uint32
        Timestamp uint32
        Expiry    uint32
        KeySize   uint32
        ValSize   uint32
}

// Encode takes a byte buffer, encodes the value of header and writes to the buffer.
func (h *Header) encode(buf *bytes.Buffer) error <span class="cov10" title="3">{
        return binary.Write(buf, binary.LittleEndian, h)
}</span>

// Decode takes a record object decodes the binary value the buffer.
func (h *Header) decode(record []byte) error <span class="cov6" title="2">{
        return binary.Read(bytes.NewReader(record), binary.LittleEndian, h)
}</span>

// isExpired returns true if the key has already expired.
func (r *Record) isExpired() bool <span class="cov6" title="2">{
        // If no expiry is set, this value will be 0.
        if r.Header.Expiry == 0 </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov1" title="1">return time.Now().Unix() &gt; int64(r.Header.Expiry)</span>
}

// isValidChecksum returns true if the checksum of the value matches what is stored in the header.
func (r *Record) isValidChecksum() bool <span class="cov1" title="1">{
        return crc32.ChecksumIEEE(r.Value) == r.Header.Checksum
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package barrel

import (
        "encoding/gob"
        "os"
)

// KeyDir represents an in-memory hash for faster lookups of the key.
// Once the key is found in the map, the additional metadata like the offset record
// and the file ID is used to extract the underlying record from the disk.
// Advantage is that this approach only requires a single disk seek of the db file
// since the position offset (in bytes) is already stored.
type KeyDir map[string]Meta

// Meta represents some additional properties for the given key.
// The actual value of the key is not stored in the in-memory hashtable.
type Meta struct {
        Timestamp  int
        RecordSize int
        RecordPos  int
        FileID     int
}

// Encode encodes the map to a gob file.
// This is typically used to generate a hints file.
// Caller of this program should ensure to lock/unlock the map before calling.
func (k *KeyDir) Encode(fPath string) error <span class="cov10" title="3">{
        // Create a file for storing gob data.
        file, err := os.Create(fPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="3">defer file.Close()

        // Create a new gob encoder.
        encoder := gob.NewEncoder(file)

        // Encode the map and save it to the file.
        err = encoder.Encode(k)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="3">return nil</span>
}

// Decode decodes the gob data in the map.
func (k *KeyDir) Decode(fPath string) error <span class="cov0" title="0">{
        // Open the file for decoding gob data.
        file, err := os.Open(fPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Create a new gob decoder.
        decoder := gob.NewDecoder(file)

        // Decode the file to the map.
        err = decoder.Decode(k)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package barrel

import (
        "bytes"
        "fmt"
        "hash/crc32"
        "time"

        "github.com/codeharik/GoMQ/pkg/datafile"
)

func (b *Barrel) get(k string) (Record, error) <span class="cov10" title="3">{
        // Check for entry in KeyDir.
        meta, ok := b.keydir[k]
        if !ok </span><span class="cov1" title="1">{
                return Record{}, ErrNoKey
        }</span>

        <span class="cov6" title="2">var (
                // Header object for decoding the binary data into it.
                header Header
                reader *datafile.DataFile
        )

        // Set the current file ID as the default.
        reader = b.df

        // Check if the ID is different from the current ID.
        if meta.FileID != b.df.ID() </span><span class="cov0" title="0">{
                reader, ok = b.stale[meta.FileID]
                if !ok </span><span class="cov0" title="0">{
                        return Record{}, fmt.Errorf("error looking up for the db file for the given id: %d", meta.FileID)
                }</span>
        }

        // Read the file with the given offset.
        <span class="cov6" title="2">data, err := reader.Read(meta.RecordPos, meta.RecordSize)
        if err != nil </span><span class="cov0" title="0">{
                return Record{}, fmt.Errorf("error reading data from file: %v", err)
        }</span>

        // Decode the header.
        <span class="cov6" title="2">if err := header.decode(data); err != nil </span><span class="cov0" title="0">{
                return Record{}, fmt.Errorf("error decoding header: %v", err)
        }</span>

        <span class="cov6" title="2">var (
                // Get the offset position in record to start reading the value from.
                valPos = meta.RecordSize - int(header.ValSize)
                // Read the value from the record.
                val = data[valPos:]
        )

        record := Record{
                Header: header,
                Key:    k,
                Value:  val,
        }

        return record, nil</span>
}

func (b *Barrel) put(df *datafile.DataFile, k string, val []byte, expiry *time.Time) error <span class="cov10" title="3">{
        // Prepare header.
        header := Header{
                Checksum:  crc32.ChecksumIEEE(val),
                Timestamp: uint32(time.Now().Unix()),
                KeySize:   uint32(len(k)),
                ValSize:   uint32(len(val)),
        }

        // Check for expiry.
        if expiry != nil </span><span class="cov1" title="1">{
                header.Expiry = uint32(expiry.Unix())
        }</span> else<span class="cov6" title="2"> {
                header.Expiry = 0
        }</span>

        // Prepare the record.
        <span class="cov10" title="3">record := Record{
                Key:   k,
                Value: val,
        }

        // Get the buffer from the pool for writing data.
        buf := b.bufPool.Get().(*bytes.Buffer)
        defer b.bufPool.Put(buf)
        // Resetting the buffer is important since the length of bytes written should be reset on each `set` operation.
        defer buf.Reset()

        // Encode header.
        header.encode(buf)

        // Write key/value.
        buf.WriteString(k)
        buf.Write(val)

        // Append to underlying file.
        offset, err := df.Write(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing data to file: %v", err)
        }</span>

        // Add entry to KeyDir.
        // We just save the value of key and some metadata for faster lookups.
        // The value is only stored in disk.
        <span class="cov10" title="3">b.keydir[k] = Meta{
                Timestamp:  int(record.Header.Timestamp),
                RecordSize: len(buf.Bytes()),
                RecordPos:  offset + len(buf.Bytes()),
                FileID:     df.ID(),
        }

        // Ensure filesystem's in memory buffer is flushed to disk.
        if b.opts.alwaysFSync </span><span class="cov0" title="0">{
                if err := df.Sync(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error syncing file to disk: %v", err)
                }</span>
        }

        <span class="cov10" title="3">return nil</span>
}

func (b *Barrel) delete(k string) error <span class="cov1" title="1">{
        // Store an empty tombstone value for the given key.
        if err := b.put(b.df, k, []byte{}, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete it from the map as well.
        <span class="cov1" title="1">delete(b.keydir, k)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package barrel

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
)

// Exists returns true if the given path exists on the filesystem.
func exists(path string) bool <span class="cov10" title="6">{
        if _, err := os.Stat(path); err != nil </span><span class="cov10" title="6">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// getDataFiles returns the list of db files in a given directory.
func getDataFiles(dir string) ([]string, error) <span class="cov6" title="3">{
        files, err := filepath.Glob(fmt.Sprintf("%s/*.db", dir))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="3">return files, nil</span>
}

// getIDs return the sorted list of IDs extracted from the list of filenames.
func getIDs(files []string) ([]int, error) <span class="cov0" title="0">{
        ids := make([]int, 0)

        for _, f := range files </span><span class="cov0" title="0">{
                id, err := strconv.ParseInt((strings.TrimPrefix(strings.TrimSuffix(filepath.Base(f), ".db"), "barrel_")), 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">ids = append(ids, int(id))</span>
        }

        // Sort in increasing order.
        <span class="cov0" title="0">sort.Ints(ids)

        return ids, nil</span>
}

// validateKV validates key/value before inserting.
func validateKV(k string, val []byte) error <span class="cov4" title="2">{
        if len(k) == 0 </span><span class="cov0" title="0">{
                return ErrEmptyKey
        }</span>

        <span class="cov4" title="2">if len(k) &gt; MaxKeySize </span><span class="cov0" title="0">{
                return ErrLargeKey
        }</span>

        <span class="cov4" title="2">if len(val) &gt; MaxValueSize </span><span class="cov0" title="0">{
                return ErrLargeValue
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package datafile

import (
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

const (
        ACTIVE_DATAFILE = "barrel_%d.db"
)

type DataFile struct {
        sync.RWMutex

        writer *os.File
        reader *os.File
        id     int

        offset int
}

// New initialises a db store for storing/reading an active db file.
// At a given time only one file can be active.
func New(dir string, index int) (*DataFile, error) <span class="cov7" title="3">{
        // If the file doesn't exist, create it, or append to the file.
        path := filepath.Join(dir, fmt.Sprintf(ACTIVE_DATAFILE, index))
        writer, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening file for writing db: %w", err)
        }</span>

        // Create a reader for reading the db file.
        <span class="cov7" title="3">reader, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening file for reading db: %w", err)
        }</span>

        // Get the offset for the current file.
        <span class="cov7" title="3">stat, err := writer.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error fetching file stats: %v", err)
        }</span>

        <span class="cov7" title="3">df := &amp;DataFile{
                writer: writer,
                reader: reader,
                id:     index,
                offset: int(stat.Size()),
        }

        return df, nil</span>
}

// ID returns the ID of the datafile.
func (d *DataFile) ID() int <span class="cov10" title="5">{
        return d.id
}</span>

// Size returns the size of DB file in bytes.
func (d *DataFile) Size() (int64, error) <span class="cov0" title="0">{
        // Use stat to get file syze in bytes.
        stat, err := d.writer.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("error fetching file stats: %v", err)
        }</span>

        <span class="cov0" title="0">return stat.Size(), nil</span>
}

// Sync flushes the in-memory buffers to the disk.
func (d *DataFile) Sync() error <span class="cov1" title="1">{
        return d.writer.Sync()
}</span>

func (d *DataFile) Read(pos int, size int) ([]byte, error) <span class="cov4" title="2">{
        // Byte position to read the file from.
        start := int64(pos - size)

        // Initialise a buffer for reading data.
        record := make([]byte, size)

        // Read the file with the given offset.
        n, err := d.reader.ReadAt(record, start)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if the size of bytes read matches the record size.
        <span class="cov4" title="2">if n != int(size) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error fetching record, invalid size")
        }</span>

        <span class="cov4" title="2">return record, nil</span>
}

// Write writes the record to the underlying db file.
func (d *DataFile) Write(data []byte) (int, error) <span class="cov7" title="3">{
        if _, err := d.writer.Write(data); err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        // Store the current size of the file.
        <span class="cov7" title="3">offset := d.offset

        // Increase the offset of the current active file.
        d.offset += len(data)

        return offset, nil</span>
}

// Close closes the file descriptors of the underlying db file.
func (d *DataFile) Close() error <span class="cov7" title="3">{
        if err := d.writer.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">if err := d.reader.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
